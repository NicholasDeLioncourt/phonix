<a name="Top"></a>

<h2 class="unnumbered">Phonix Phonological Transformation Language</h2>

<p>This is the manual for Phonix, a language for expressing diachronic and
synchronic phonological processes.

<p>$LastChangedDate: 2010-01-16 18:56:12 -0800 (Sat, 16 Jan 2010) $

   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Phonix Phonological Transformation Language</a>
<li><a name="toc_Quick-Start" href="#Quick-Start">1 Quick Start Guide</a>
<li><a name="toc_How-To-Use-Phonix" href="#How-To-Use-Phonix">2 How To Use Phonix</a>
<li><a name="toc_The-Phonix-Language" href="#The-Phonix-Language">3 The Phonix Language</a>
<ul>
<li><a href="#Features">3.1 Features</a>
<ul>
<li><a href="#Basic-Features">3.1.1 Basic Features</a>
<li><a href="#Unary-Features">3.1.2 Unary Features</a>
<li><a href="#Binary-Features">3.1.3 Binary Features</a>
<li><a href="#Scalar-Features">3.1.4 Scalar Features</a>
<li><a href="#Node-Features">3.1.5 Node Features</a>
</li></ul>
<li><a href="#Feature-Matrices">3.2 Feature Matrices</a>
<li><a href="#Symbols">3.3 Symbols</a>
<li><a href="#Rules">3.4 Rules</a>
<ul>
<li><a href="#Parts-of-a-rule">3.4.1 Parts of a rule</a>
<li><a href="#Basic-transformations">3.4.2 Basic transformations</a>
<li><a href="#Inserting-and-deleting">3.4.3 Inserting and deleting</a>
<li><a href="#Variable-feature-values">3.4.4 Variable feature values</a>
<li><a href="#Node-feature-values">3.4.5 Node feature values</a>
<li><a href="#Assimilation-and-gemination">3.4.6 Assimilation and gemination</a>
<li><a href="#Rule-parameters">3.4.7 Rule parameters</a>
<ul>
<li><a href="#Direction">3.4.7.1 Direction</a>
<li><a href="#Filter">3.4.7.2 Filter</a>
</li></ul>
</li></ul>
<li><a href="#Imports">3.5 Imports</a>
<ul>
<li><a href="#Importing-files">3.5.1 Importing files</a>
<li><a href="#std_002efeatures">3.5.2 std.features</a>
<li><a href="#std_002esymbols">3.5.3 std.symbols</a>
<li><a href="#std_002esymbols_002eipa">3.5.4 std.symbols.ipa</a>
</li></ul>
<li><a href="#Comments">3.6 Comments</a>
<li><a href="#Strings">3.7 Strings</a>
</li></ul>
<li><a name="toc_Examples" href="#Examples">4 Examples</a>
<ul>
<li><a href="#Romanian">4.1 Romanian</a>
<ul>
<li><a href="#Romanian">4.1.1 <samp><span class="file">romanian.phonix</span></samp></a>
<li><a href="#Romanian">4.1.2 Input and output</a>
</li></ul>
</li></ul>
<li><a name="toc_License" href="#License">Appendix A License</a>
</li></ul>
</div>

<p><a name="Quick-Start"></a>

<h2 class="chapter">1 Quick Start Guide</h2>

<p>You are a busy person. You have sound changes to apply and phonologies to
crunch and you do not have time to read a whole manual. This section is for
you. Writing your first phonology is very easy: all that you need to do is open
up a text file and type the following:

<pre class="example">     import std.features
     import std.symbols
</pre>
   <p>The first line will automatically add the standard feature set to your
phonology. The second line will add the standard symbol set.  Together, these
provide you with a set of contrastive features and phonetic symbols to allow
you express whatever phonological processes you desire. You can find out more
by reading <a href="#std_002efeatures">std.features</a> and <a href="#std_002esymbols">std.symbols</a>.

   <p>But you've only started. Your phonology contains rules, and the first and most
important rule in your phonology is I-Nasal. This rule expressed in English is
"every front vowel must be /i/ if the next segment is /n/". (This is, perhaps, not a
very realistic rule, but we're doing this for the sake of simplicity.) In
Phonix, you will write this as such:

<pre class="example">     rule i-nasal
     [-cons +fr] =&gt; i / _n
</pre>
   <p>A well educated phonologist such as yourself will immediately recognize the
notation being used here. The portion <code>[-cons +fr]</code> is a <dfn>feature
matrix</dfn> that specifies non-consonantal front segments (i.e. front vowels), and
the notation <code>=&gt; i</code> may be read as "becomes /i/". The portion following
the <code>/</code> is the <dfn>context</dfn>, and the context for this rule is <code>_n</code>,
which we read as "when followed by /n/".

   <p>If you didn't understand that, you should read <a href="#Rules">Rules</a>, which has a much
fuller explanation. You may also look at the <a href="#Romanian">Romanian</a> for examples of
other Phonix rules.

   <p>Save your phonology in a file called <samp><span class="file">my.phonix</span></samp>. Let's assume that you
already have the list of underlying forms to which you wish to apply your
transformations saved in <samp><span class="file">lexicon.txt</span></samp>, with one word on each line. 
Conveniently, this is exactly the format that Phonix uses. You can then apply
your rules to your lexicon by typing the following at the command line:

   <p><samp><span class="command">phonix my.phonix -i lexicon.txt</span></samp>

   <p>This will print the output to the screen, one word on each line. Should you
wish to have Phonix save them to a file, simply provide the filename with
<samp><span class="option">-o</span></samp>:

   <p><samp><span class="command">phonix my.phonix -i lexicon.txt -o output.txt</span></samp>

<p><a name="How-To-Use-Phonix"></a>

<h2 class="chapter">2 How To Use Phonix</h2>

<p><dfn>Phonix</dfn> refers to the Phonix programming language for modeling
phonological processes, and informally to the program <samp><span class="file">phonix</span></samp> that
interprets Phonix language files and applies the rules contained therein to
a lexicon.

   <p>In order to use Phonix, you need two things:

     <ol type=1 start=1>

     <li>A <dfn>Phonix file</dfn> that contains the feature, symbol, and rule
declarations of the phonology you wish to model. Phonix files conventionally
have the extension <samp><span class="file">.phonix</span></samp> or <samp><span class="file">.phx</span></samp>.

     <li>The lexicon for your phonology&ndash;the underlying or ancestral forms before
any rules or sound-changes are applied to them&ndash;written with the symbols
defined in your Phonix file. Phonix can read the lexicon from standard input or
from a file.

        </ol>

   <p>The Phonix language is described in detail in <a href="#The-Phonix-Language">The Phonix Language</a>. This
section describes how to invoke <samp><span class="file">phonix</span></samp> to run your phonology files.

   <p>A basic invocation of Phonix looks like this:

<pre class="example">     phonix <var>phonix-file</var> <var>arguments</var>
</pre>
   <p>The only required argument is the <var>phonix-file</var>, which is a file containing
a phonology definition. The following <var>arguments</var> are optional.

     <dl>
<dt><samp><span class="option">-i </span><var>filename</var></samp><dt><samp><span class="option">--in </span><var>filename</var></samp><dd>The lexicon file from which underlying/ancestral forms are read to have the
Phonix rules applied to them. If this argument is not given, Phonix reads from
standard input.

     <br><dt><samp><span class="option">-o </span><var>filename</var></samp><dt><samp><span class="option">--out </span><var>filename</var></samp><dd>The filename to which to write output forms that the rules have applied to. If
this argument is not given, Phonix writes to standard output.

     <br><dt><samp><span class="option">-q</span></samp><dt><samp><span class="option">--quiet</span></samp><dd>When this option is present, Phonix doesn't print any errors except for fatal
error messages.

     <br><dt><samp><span class="option">-d</span></samp><dt><samp><span class="option">--debug</span></samp><dd>When this option is given, Phonix writes a variety of diagnostic messages to
the standard error stream to aid in debugging your phonology.

     <br><dt><samp><span class="option">-v</span></samp><dt><samp><span class="option">--verbose</span></samp><dd>When this option is given, Phonix logs verbosely to the standard error stream. 
This creates all of the output generated by <samp><span class="option">-d</span></samp>, plus more.

     <br><dt><samp><span class="option">-w</span></samp><dt><samp><span class="option">--warn-fatal</span></samp><dd>When this option is given, certain conditions that normally produce a warning
will cause Phonix to immediately exit.

   </dl>

   <p>Phonix requires some version of the Common Language Runtime, commonly known on
Windows as .NET. Through the Mono project, this runtime is widely available on
almost all operating systems. However, the specific way that you invoke
<samp><span class="file">phonix</span></samp> will depend slightly on your setup.

     <ol type=1 start=1>

     <li>If you are using any version of Windows and <samp><span class="file">phonix.exe</span></samp> is in the
current directory or any directory in <code>%PATH%</code>, then you can simply call
<samp><span class="file">phonix</span></samp> or <samp><span class="file">phonix.exe</span></samp>. Phonix requires .NET Framework 2.0 or
later, which is standard on all recent versions of Windows.

     <li>If you are using Linux, you can invoke Phonix with <code>./phonix.exe</code>,
provided that you have the Mono runtime installed. If you are building from
source, there is a <code>make install</code> target that will install a <samp><span class="file">phonix</span></samp>
script without the <code>.exe</code> extension in <code>/usr/local/bin</code>.

     <li>If you are using Mac OSX or a POSIX system other than Linux, you can
invoke Phonix with <code>mono phonix.exe</code>. You must have the Mono runtime
installed, and you need to explicitly call <code>mono</code> in order to run Phonix.

        </ol>

<p><a name="The-Phonix-Language"></a>

<h2 class="chapter">3 The Phonix Language</h2>

<p>This section covers the syntax and meaning of all aspects of a Phonix file in
detail. The Phonix language is simple but powerful, and it should be very easy
for people who are familiar with basic phonological concepts and rule notation. 
If you are not familiar with the basics of generative phonology, you may find
this section tough going.

   <p>The Phonix language is <dfn>declarative</dfn>: you use Phonix to create a
description of your phonology, and <code>phonix</code> reads your description and
applies the rules contained therein to the lexicon. There are three basic
elements in a Phonix file: <dfn>features</dfn>, <dfn>symbols</dfn>, and <dfn>rules</dfn>. Each
of these is built up from the previous parts: features are the most basic
element, symbols are composed of features, and rules are composed from symbols
and feature matrices.

<p><a name="Features"></a>

<h3 class="section">3.1 Features</h3>

<p>Features are the contrastive elements that compose the phonemes in your
phonology. Features must be declared before they can be used in symbols or
rules.

<p><a name="Basic-Features"></a>

<h4 class="subsection">3.1.1 Basic Features</h4>

<p>The simplest feature declaration looks like this:

<pre class="example">     
     feature <var>feature-name</var>
     
</pre>
   <p>The name of a feature can generally be anything, so long as it doesn't contain
spaces or characters with a special meaning in Phonix. For detailed rules, see
<a href="#Strings">Strings</a>. For example:

<pre class="example">     
     feature voice
     
</pre>
   <p>The preceding example creates <code>voice</code> as a <dfn>binary feature</dfn>, meaning
that it may have the values <code>+voice</code> and <code>-voice</code>. (There is also a
third value <code>*voice</code> which will be talked about shortly.) Phonix supports
three types of features: <dfn>unary</dfn>, <dfn>binary</dfn>, and <dfn>scalar</dfn>. By
default all features are binary. To declare a feature of a different type, you
must use the extended syntax:

<pre class="example">     
     feature <var>feature-name</var> (<var>parameter-name</var>=<var>parameter-value</var>)
     
</pre>
   <p>Note that the parenthesis around the parameter list is part of the syntax and
cannot be omitted. Currently the only parameters allowed on feature
declarations are <code>type</code>, which may have the values <code>unary</code>,
<code>binary</code>, <code>scalar</code>, or <code>node</code>, and <code>children</code>, which is
discussed under <a href="#Node-Features">Node Features</a>.

   <p>These feature types are discussed in detail in the following sections.

<p><a name="Unary-Features"></a>

<h4 class="subsection">3.1.2 Unary Features</h4>

<p>The following example declares a unary feature &lsquo;<samp><span class="samp">un</span></samp>&rsquo;:

<pre class="example">     
     feature un (type=unary)
     
</pre>
   <p>Unary features are either <dfn>present</dfn> or <dfn>absent</dfn>. A unary feature which
is present is written with the feature name and no other decoration: <code>un</code>. 
A unary feature which is absent is preceded by &lsquo;<samp><span class="samp">*</span></samp>&rsquo;: <code>*un</code>.

   <p>Unary features are also called "privative features" in linguistic literature.

<p><a name="Binary-Features"></a>

<h4 class="subsection">3.1.3 Binary Features</h4>

<p>The following example declares a binary feature &lsquo;<samp><span class="samp">bn</span></samp>&rsquo;:

<pre class="example">     
     feature bn (type=binary)
     
</pre>
   <p>Binary features have both <dfn>positive</dfn> and <dfn>negative</dfn> values, written as
<code>+bn</code> and <code>-bn</code> respectively. Additionally, a binary feature may be
<dfn>absent</dfn>, which is written the same way as for unary features: <code>*bn</code>. 
For example, the features &lsquo;<samp><span class="samp">anterior</span></samp>&rsquo; and &lsquo;<samp><span class="samp">distributed</span></samp>&rsquo; are not
meaningful except as applied to coronals, so a labial segment would have the
value <code>*anterior</code>.

<p><a name="Scalar-Features"></a>

<h4 class="subsection">3.1.4 Scalar Features</h4>

<p>The following example declares a scalar feature:

<pre class="example">     feature sc (type=scalar)
</pre>
   <p>Scalar features may have any non-negative integer value, and are written as
<code>sc=</code><var>value</var>. For example, <code>sc=0</code>, <code>sc=1</code>, and
<code>sc=123456789</code> are all valid scalar feature values. However, <code>sc=-1</code>
and <code>sc=foo</code> are not valid. Scalar features may also be absent, in which
case they are written <code>*sc</code>.

<p><a name="Node-Features"></a>

<h4 class="subsection">3.1.5 Node Features</h4>

<p>Node features are used to represent <em>feature trees</em>, as used in many
phonologcal theories. All of the other feature types are single features with
their own values. A node feature, on the other hand, represents a collection of
child features, and the value of a node feature is the value of all of its
children.

   <p>A node feature is declared with the parameter <code>type=node</code> and the
<code>children</code> parameter. For example:

<pre class="example">     feature nd (type=node children=a,b.c)
</pre>
   <p>The <code>children</code> parameter is required for node features, and forbidden on
all other feature types. Its value is a list of the child features, separated
by commas. You cannot put spaces after the commas unless you put the whole list
in quotes, e.g. <code>children=a,b,c</code> or <code>children="a, b, c"</code>. The
features that you declare as children must have been declared before you
declare the node feature.

   <p>Feature nodes can have any kind of feature as a child, including other nodes. 
This allows you to create a multi-level hierarchies. For an example of such a
feature tree, see <a href="#std_002efeatures">std.features</a>.

   <p>Feature nodes are <dfn>present</dfn> if any of their child features are present
(i.e. if any child feature has a value other than <code>*feature</code>), otherwise
they are <dfn>absent</dfn>. Feature nodes are written the same way as unary
features, with <code>nd</code> for present and <code>*nd</code> for absent. Note that there
are some restrictions on where you can use node feature values.

     <ul>
<li>Node feature values can't be used at all in symbol declarations. Symbols
can only contain leaf features.

     <li>Present values can only be used in the <dfn>match</dfn> and <dfn>context</dfn>
portions of a rule. This is because it isn't meaningful to assign a "present"
value directly to a node.

   </ul>
   <a name="Feature-Matrices"></a>

<h3 class="section">3.2 Feature Matrices</h3>

<p>A <dfn>feature matrix</dfn> is a set of features and their values, enclosed in
&lsquo;<samp><span class="samp">[]</span></samp>&rsquo;. The following line represents a feature matrix.

<pre class="example">     [+cons -son -cont -str -vc -ro]
</pre>
   <p>Features that are present in your phonology but which are not listed in a
feature matrix are assumed to have the <dfn>absent</dfn> value. In the feature
matrix above, the vocalic feature <code>fr</code> (front) is unspecified, so it has
the default value of <code>[*fr]</code>.

   <p>Feature matrices are used to define symbols and rules. However, only unary,
binary, and scalar feature values can appear in symbols. Node feature values
and variable feature values cannot be used in symbol declarations.

<p><a name="Symbols"></a>

<h3 class="section">3.3 Symbols</h3>

<p>A <dfn>symbol</dfn> in Phonix is a string of text that corresponds to a given
feature matrix. Symbols are used for three things:

     <ol type=1 start=1>

     <li>To define the feature matrices represented by the strings in your lexicon
files.

     <li>To provide a convenient shortcut for writing rules that refer to specific
phonemes.

     <li>To define the strings used to represent feature matrices in output.

        </ol>

   <p>A symbol declaration looks like this:

<pre class="example">     
     symbol <var>symbol-string</var> <var>feature-matrix</var>
     
</pre>
   <p>For example, this is the declaration of the symbol &lsquo;<samp><span class="samp">s</span></samp>&rsquo; in the standard
symbol set:

<pre class="example">     
     symbol s [+cons -son +cont +str -vc +ant -dist]
     
</pre>
   <p>Any Unicode character that doesn't have a special meaning in Phonix can be used
in a symbol. So if you want to define ☃ (Unicode snowman) as a symbol in your
phonology, you go ahead and do that.

   <p>Symbols are not limited to single characters, either. The only caveat for
multi-character symbols is that Phonix always maps your input to the longest
matching symbol. For example, say you define the following symbols:

<pre class="example">     symbol s  [...]
     symbol k  [...]
     symbol sk [...]
</pre>
   <p>If your input or rules contain the characters &lsquo;<samp><span class="samp">sk</span></samp>&rsquo;, these will be mapped
to the symbol /sk/, and not to the sequence /s/+/k/. To disambiguate such
strings in your rules, you can add spaces. The string <code>s k</code> appearing in a
rule will always be interpreted as /s/+/k/.

   <p>For many examples of symbol definitions, see <a href="#std_002esymbols">std.symbols</a>.

<p><a name="Rules"></a>

<h3 class="section">3.4 Rules</h3>

<p>The <dfn>rule</dfn> is the most complex and the most useful object in Phonix. A rule
describes the conditions under which one phonological unit is transformed into
another.

<p><a name="Parts-of-a-rule"></a>

<h4 class="subsection">3.4.1 Parts of a rule</h4>

<p>A complete rule has the following syntax:

<pre class="example">     rule <var>name</var> (<var>parameters</var>) <var>match</var> =&gt; <var>action</var> / <var>context</var> // <var>excluded-context</var>
</pre>
     <ul>
<li>The <dfn>name</dfn> of the rule can be any Phonix string. See <a href="#Strings">Strings</a>.

     <li>The <dfn>parameters</dfn> are optional and define characteristics of how the
rule is applied. If you don't apply any parameters, you can omit the
parenthesis. Currently the supported parameters for rules are <code>filter</code> and
<code>direction</code>. See <a href="#Rule-parameters">Rule parameters</a>.

     <li>The <dfn>match</dfn> is a sequence of feature matrices or symbols that matches
the segments that the transformation works on.

     <li>The <dfn>action</dfn> is sequence of feature matrices or symbols that defines
the transformations applied to the match.

     <li>The <dfn>context</dfn> defines the conditions under which the transformation
occurs. These are the adjacent segments which aren't themselves altered, but
which are required to trigger the rule. If the rule is <dfn>unconditional</dfn> and
does not depend on the surrounding segments, you can omit the context and the
excluded context.

     <li>The <dfn>excluded-context</dfn> defines conditions under which the rule should
not apply. Thus, this indicates exceptions to the conditions in the context.

   </ul>

   <p>These are described in more detail in the following sections.

<p><a name="Basic-transformations"></a>

<h4 class="subsection">3.4.2 Basic transformations</h4>

<p>The simplest transformation is one that has no context or parameters and acts
only on a single phoneme, as in the following example.

<pre class="example">     rule s-to-z s =&gt; z
</pre>
   <p>The <dfn>match</dfn> here is the segment /s/, and the <dfn>action</dfn> is to turn all
such segments into /z/. Since /s/ and /z/ differ only by voice, we can also
write this rule like this (using the appreviation <code>vc</code> for voice, as in
the standard feature set):

<pre class="example">     rule s-voicing s =&gt; [+vc]
</pre>
   <p>Here the action is a feature matrix rather than a segment. The effect of this
is to take whichever value for <code>voice</code> the input previously had and
replace it with <code>+voice</code>. You can use a feature matrix in the match to
match against a class of segments:

<pre class="example">     rule continuant-voicing [+cont] =&gt; [+vc]
</pre>
   <p>This matches all segments that have the feature <code>+cont</code> and applies the
feature <code>+vc</code> to them.

   <p>Most rules do not apply everywhere, however, but have some <dfn>context</dfn>. The
context consists of, at minimum, the character <code>_</code> with any number of
feature matrices or symbols before or after it. The <code>_</code> character stands
for the segment(s) of the match/action. Regardless of how many segments are
matched or transformed, you must write only one underscore. For example, let's
modify our previous rule to only apply after a nasal:

<pre class="example">     rule postnasal-voicing [+cont] =&gt; [+vc] / [+nas] _
</pre>
   <p>In this case, the context <code>/ [+nas] _</code> indicates that the segments matched
must be preceded by a segment with the feature <code>+nas</code>.

   <p>To indicate word boundaries we use <code>$</code>. The <code>$</code> character can stand
for either the beginning or the end of a word. It can only appear as the first
or the last character of the rule context (or both), but it cannot appear
internal to a rule. Suppose that we wish to further restrict our rule to only
apply at the end of a word. In this case, we write this:

<pre class="example">     rule final-postnasal-voicing
     [+cont] =&gt; [+vc] / [+nas] _ $
</pre>
   <p>(Note that we've broken this rule into two lines. This is perfectly acceptable:
Phonix is usually indifferent to the spaces and line breaks in your phonology
file.)

   <p>If we wish to add an exception to this rule, we use the <em>excluded
context</em>. This is indicated by a double-slash <code>//</code> after the context. If
the rule includes an excluded context, then phonix will check both that the
context matches the input and that the excluded context does <em>not</em> match. 
For example:

<pre class="example">     rule postnasal-voicing-with-exception
     [+cont] =&gt; [+vc] / [+nas] _ // N _
</pre>
   <p>Here we voice continuants after nasals, <em>except</em> after /N/ (the velar
nasal).

   <p>If you wish, you can also indicate the excluded context without the context:

<pre class="example">     rule voicing-with-exception
     [+cont] =&gt; [+vc] // $ _
</pre>
   <p>This voices all continuants unless they are the first segment in the word. Note
that we could accomplish the exact same thing with:

<pre class="example">     rule voicing-with-exception
     [+cont] =&gt; [+vc] / [] _
</pre>
   <p>Here, we specify that voicing occurs when the continuant is preceded by any
segment. (A feature matrix with no values <code>[]</code> effectively acts as a match
for any segment.) This illustrates that an excluded context can usually be
indicated by a properly constructed matching context and vice-versa. The
excluded context construct is provided only to make rules clearer and easier to
understand.

<p><a name="Inserting-and-deleting"></a>

<h4 class="subsection">3.4.3 Inserting and deleting</h4>

<p>Insertion and deletion rules are written with the help of the special character
<code>*</code>, which you should think of as "nothing". To write an insertion rule,
specify that "nothing" becomes something:

<pre class="example">     rule e-epenthesis
     * =&gt; e / $ _ s[-cont]
</pre>
   <p>This is the familiar rule found in many Romance languages which adds an
epenthetic /e/ following an initial cluster with /s/.

   <p>The opposite of insertion is deletion, in which something becomes nothing. 
E.g.:

<pre class="example">     rule final-cons-deletion
     [-son] =&gt; * / _ $
</pre>
   <p>Here, the "something" is any non-sonorant (<code>-son</code>), which becomes nothing
when followed by the word boundary.

   <p>Our nothing character is important when writing coalescence rules, in which
multiple segments become one. For example, to express that /s/+/k/ becomes /S/,
you <em>cannot</em> write the following:

<pre class="example">     # DOES NOT WORK - Phonix will not compile this line
     rule sk-coalescence sk =&gt; S
</pre>
   <p>The problem with this is that you must have the same number of segments both
before and after the <code>=&gt;</code> symbol. To accomplish what you want, just add a
little nothing to balance out the rule:

<pre class="example">     rule sk-coalescence sk =&gt; S*
</pre>
   <p>This rule will compile and function as expected.

<p><a name="Variable-feature-values"></a>

<h4 class="subsection">3.4.4 Variable feature values</h4>

<p>It is common for linguistic rules to require that features on related segments
be the same without specifying what the particular value is. The linguistic
literature traditionally indicates such values with Greek letters to represent
the variables. Phonix allows you to indicate such rules without the Greek using
<dfn>variable feature values</dfn>, which are indicated by <code>$</code>. In general, a
variable feature value indicated by <code>$</code><var>feature-name</var> means that
<var>feature-name</var> must have the same value everywhere it appears.

   <p>Consider the following rule:

<pre class="example">     rule cluster-spirantization [$vc -son] =&gt; [+cont] / _ [$vc -son]
</pre>
   <p>This rule in English reads as "spirantize any non-sonorant when followed by
another non-sonorant of the same voicing". The feature values <code>-son</code> and
<code>+cont</code> are ordinary feature values and indicate that both the matched
segment and the following context segment must be non-sonorants, and that the
matched segment becomes a continuant. The feature value <code>$vc</code> is
different: it doesn't stipulate <code>+vc</code> or <code>-vc</code>, but rather requires
that the value for <code>vc</code> be the same in both the match and context
segments.

   <p>This extends to rule actions, which is perhaps a more common case. The
following illustrates a nasal assimilation rule:

<pre class="example">     rule nasal-assimilate [-cont] =&gt; [$nas $son] / _ [-cont $nas $son]
</pre>
   <p>This rule reads as "any non-continuant takes the nasality and sonority of a
following non-contiuant segment". This will cause, for example /d/+/m/ to
become /n/+/m/, while /n/+/b/ becomes /d/+/b/. The values <code>$nas $son</code> in
the rule action have the effect of setting <code>nas</code> and <code>son</code> in the
matched segment to whatever value they have in the context segment.

   <p>In order for a variable feature value to be meaningful, it has to occur at
least twice in a rule. Consider the following modified example:

<pre class="example">     rule nasal-assimilate-mod [-cont] =&gt; [$nas] / _ [-cont $nas $son]
</pre>
   <p>This rule parses and executes without any warning, but the value <code>$son</code>
has no effect, because it has to occur in at least two places in order to match
or transform anything.

   <p>The following example, however, will generate a warning whenever the rule
applies:

<pre class="example">     rule nasal-assimilate-mod [-cont] =&gt; [$nas $son] / _ [-cont $nas]
</pre>
   <p>In this case we are trying to set the value of <code>son</code> in the rule action,
but the value the value for <code>son</code> is not defined anywhere else in the
rule. Since this usually indicates a mistake, Phonix issues a warning and leave
the value of <code>son</code> unchanged.

<p><a name="Node-feature-values"></a>

<h4 class="subsection">3.4.5 Node feature values</h4>

<p>Node features are features with one or more child features (see <a href="#Node-Features">Node Features</a>), and they have some special properties.

   <p>A node feature is <dfn>present</dfn> if one or more of its children is present. Node
features don't have any value of their own. Within a rule you can use the same
syntax that is used for unary values to test for the presence of a node:

<pre class="example">     rule postlabial-centralization
     [+fr -bk] =&gt; [-fr] / [Labial] _
</pre>
   <p>In this case we are testing for the presence of the <code>Labial</code> node. This is
especially convenient because it allows us to capture both <code>+ro</code> segments
(rounded vowels) and <code>-ro</code> segments (labial consonants), which otherwise
can't be represented in a natural class.

   <p>Conversely, you can test for the absence of a particular node by testing for
<code>*Labial</code>. The following rule centralizes vowels after non-<code>Coronal</code>
segments.

<pre class="example">     rule nonlabial-centralization
     [+fr -bk] =&gt; [-fr] / [*Coronal] _
</pre>
   <p>Within the action portion of a rule, you can use this syntax to set an entire
group of segments to their absent values. For example, the following rule
reduces all stops in final position to /?/ by removing all of their segments
under the <code>Place</code> node.

<pre class="example">     rule final-glottalization
     [-cont] =&gt; [*Place] / _ $
</pre>
   <p>As this rule illustrates, you may use the <code>*Node</code> syntax in a rule action,
but you cannot use the <code>Node</code> syntax in an action, because it makes no
sense to assign a value directly to a node. A node is present if one of its
children is present, so in order to make a node be present, assign a value to
one of its children.

<p><a name="Assimilation-and-gemination"></a>

<h4 class="subsection">3.4.6 Assimilation and gemination</h4>

<p>Node features (see <a href="#Node-Features">Node Features</a>) are especially useful for assimilation and
gemination rules. One of the most common phonological processes
cross-linguistically is <em>nasal place assimilation</em>, by which nasals in
coda positions take on the place of the following segments. These rules can be
written with a flat feature set by using several different variable values, for
every feature that represents a part of the notion of "place". However, this
can get very cumbersome&ndash;consider that to write a <em>total</em> assimilation
rule, you would need to mention write every single feature in your phonology as
a variable in your rule.

   <p>However, these processes are considerably simplified by using node features. 
For example, using <a href="#std_002efeatures">std.features</a>, we can write a nasal place assimilation
rule as follows:

<pre class="example">     rule nasal-place-assimilation
     [+nas] =&gt; [$Place] / _ [+cons $Place]
</pre>
   <p>This rule is greatly simplified by using the <code>Place</code> node, which has as
its children all of the features that contribute to place of articulation. You
can extend this even further for a gemination rule that duplicates <em>all</em>
of the features for a given segment:

<pre class="example">     rule intervocalic-gemination
     * =&gt; [$ROOT] / [-cons][+cons $ROOT] _ [-cons]
</pre>
   <p>Here a consonantal segment is doubled when surrounded on either side by
non-consonantal segments. The feature <code>ROOT</code> has as its children every
feature in <code>std.features</code>, and so the inserted segment copies every value
from the preceding segment.

<p><a name="Rule-parameters"></a>

<h4 class="subsection">3.4.7 Rule parameters</h4>

<p>Rule parameters alter the execution of your rule in some way that can't be
indicated in the rule itself. Parameters take the form
<var>param-name</var><code>=</code><var>param-value</var>, and are enclosed in parentheses
after the rule name, with spaces between them if there are more than one. The
following rule example specifies the <code>direction</code> and <code>filter</code>
parameters:

<pre class="example">     rule leftward-example (direction=right-to-left filter=[+cons]) s =&gt; z
</pre>
   <p>Supported rule parameters are discussed below.

<p><a name="Direction"></a>

<h5 class="subsubsection">3.4.7.1 Direction</h5>

<p>The rule direction defines in which direction the rule scans for matching
contexts. This can be important if one application of a rule may create the
context for further applications. To specify the direction for a rule, specify
the parameter <code>direction=</code><var>direction-value</var>. Valid direction values
are <code>left-to-right</code> and <code>right-to-left</code>, with <code>left-to-right</code> as
the default.

   <p>A good example for a direction-sensitive rule is voice agreement. Suppose we
have a rule that all consonants in a cluster must agree with the voice of the
last consonant. The following rule does not accomplish that:

<pre class="example">     # This doesn't work as expected
     rule voicing-agreement
     [+cons] =&gt; [+vc] / _ [+cons +vc]
</pre>
   <p>Given an input word like <code>astga</code>, the output of this rule will be
<code>asdga</code>&mdash;only the second consonant in the cluster is affected. This is
because the default rule direction is to the right. First the /s/ is evaluated,
but this /s/ is followed by /t/, so the rule does not apply. Then the /t/
followed by /g/ is evaluated. This does match the required context, so /t/
becomes /d/. However, the /s/ is never reevaluated. To fix this, specify that
the rule applies from the right to the left:

<pre class="example">     rule voicing-agreement (direction=right-to-left)
     [+cons] =&gt; [+vc] / _ [+cons +vc]
</pre>
   <p>This rule will transform <code>astga</code> into <code>azdga</code>. First /t/ followed by
/g/ is evaluated, transforming the /t/ into /d/, then /s/ followed by /d/ is
evaluated, giving /z/.

<p><a name="Filter"></a>

<h5 class="subsubsection">3.4.7.2 Filter</h5>

<p>Rule filters are a powerful way to express rules that only apply to certain
classes of segments and ignore intervening segments. The most familiar
real-world example of this is vowel harmony, which typically works on vowels
regardless of intervening consonants. To add a filter to a rule, specify the
parameter <code>filter=</code><var>filter-value</var>, where the filter value may be a feature
matrix or a symbol.

   <p>When you apply a filter, the rule acts as if those segments not matching the
filter were not present at all in the input. Take the following vowel harmony
rule:

<pre class="example">     rule vowel-harmony (filter=[+syll])
     [-fr] =&gt; [+fr -bk] / _ [+fr]
</pre>
   <p>This rule turns back vowels into front vowels when followed by other front
vowels, and will work correctly regardless of how many non-vowel segments
intervene between the vowels. The filter <code>[+syll]</code> effectively removes all
non-syllabic constants from the input for the duration of the rule. Therefore,
the context of the rule is written as if the front vowel that triggers vowel
harmony immediately follows the matching vowel.

<p><a name="Imports"></a>

<h3 class="section">3.5 Imports</h3>

<p>You can include Phonix files from other Phonix files using the <code>import</code>
command. There are also several built-in resources that you can use, which are
covered in this section.

<p><a name="Importing-files"></a>

<h4 class="subsection">3.5.1 Importing files</h4>

<pre class="example">     import <var>filename</var>
</pre>
   <p>The <dfn>filename</dfn> given to the import command follows the same rules as other
Phonix strings, which means that you need to quote it if it contains certain
characters that have special meaning for Phonix. For details, See <a href="#Strings">Strings</a>. 
Examples:

<pre class="example">     import other-phonology.phonix
     import "/home/linguist/latin.phonix"
     import "C:\greek.phonix"
</pre>
   <p>If the file name that you give after <code>import</code> is not an absolute path
(however that is defined on your local system), Phonix looks for the file you
imported in the following places:

     <ol type=1 start=1>

     <li>In the current directory.

     <li>In the same directory as the Phonix file currently being parsed (if that
directory is different from the current directory).

     <li>In a named resource.

        </ol>

   <p>The <dfn>named resources</dfn> that Phonix looks for are special "filenames" that
represent built-in feature or symbol sets meant to simplify common linguistic
tasks. The following sections describe these resources.

<p><a name="std.features"></a>
<a name="std_002efeatures"></a>

<h4 class="subsection">3.5.2 std.features</h4>

<p>The standard feature set contains the commonly used features that you probably
learned about in your introductory Phonology class. You include the standard
feature set by writing <code>import std.features</code>. All of the features in the
standard set are binary features given in their abbreviated forms. The features
are gathered into a feature tree following this naming convention: leaf
features are written in lower case, node features are written in initial caps,
and the <code>ROOT</code> feature is written in all caps. The tree has the following
structure:

<pre class="example">     +ROOT
         +Place
             +Labial
                 -ro
             +Coronal
                 -ant
                 -dist
             +Dorsal
                 -hi
                 -lo
                 -bk
                 -fr
         +Glottal
             -vc
             -sg
             -cg
         +Manner
             -cont
             -nas
             -str
             -lat
             -dr
             +Class
                 -cons
                 -syll
                 -son
</pre>
   <p>The <code>std.features</code> file itself looks like this:

<pre class="example"><pre class="verbatim">     # Segment classes
     feature cons    # consonantal
     feature son     # sonorant
     feature syll    # syllabic
     feature Class (type=node children=cons,son,syll)
     
     # Glottal features
     feature vc      # voice
     feature sg      # spread glottis
     feature cg      # constricted glottis
     feature Glottal (type=node children=vc,sg,cg)
     
     # Manner of articulation
     feature cont    # continuant
     feature nas     # nasal
     feature str     # strident
     feature lat     # lateral
     feature dr      # delayed-release
     feature Manner (type=node children=cont,nas,str,lat,dr,Class)
     
     # Labial features
     feature ro      # round
     feature Labial (type=node children=ro)
     
     # Coronal features
     feature ant     # anterior
     feature dist    # distributed
     feature Coronal (type=node children=ant,dist)
     
     # Dorsal features
     feature hi      # high
     feature lo      # low
     feature bk      # back
     feature fr      # front
     feature Dorsal (type=node children=hi,lo,bk,fr)
     
     # The Place node governs all place-of-articulation features
     feature Place (type=node children=Labial,Coronal,Dorsal)
     
     # The ROOT node governs all features
     feature ROOT (type=node children=Place,Glottal,Manner,Class)
</pre></pre>
   <p><a name="std.symbols"></a>
<a name="std_002esymbols"></a>

<h4 class="subsection">3.5.3 std.symbols</h4>

<p>The standard symbol set contains over 100 phonetic symbols that you can use for
input and output. In order to use the standard symbol set, you have to first
import the standard feature set <code>std.features</code>, since the standard symbols
depend on the features defined in that set. You include the standard symbols by
writing <code>import std.symbols</code>. The standard symbol set uses only 7-bit
ASCII characters and is based on the X-SAMPA IPA encoding.

<pre class="example"><pre class="verbatim">     ### CONSONANTS ###
     
     ## Obstruents ##
     
     # Labial #
     
     symbol p   [+cons -son -cont -vc -ro]
     symbol p\  [+cons -son +cont -str -vc -ro]
     symbol f   [+cons -son +cont +str -vc -ro]
     symbol b   [+cons -son -cont +vc -ro]
     symbol B   [+cons -son +cont -str +vc -ro]
     symbol v   [+cons -son +cont +str +vc -ro]
     
     # Dental #
     
     symbol T   [+cons -son +cont -str -vc +ant +dist]
     symbol D   [+cons -son +cont -str +vc +ant +dist]
     
     # Alveolar #
     
     symbol t   [+cons -son -cont -vc +ant -dist]
     symbol s   [+cons -son +cont +str -vc +ant -dist]
     symbol d   [+cons -son -cont +vc +ant -dist]
     symbol z   [+cons -son +cont +str +vc +ant -dist]
     
     # Palatal #
     
     symbol c   [+cons -son -cont -vc -ant +dist]
     symbol C   [+cons -son +cont -str -vc -ant +dist]
     symbol S   [+cons -son +cont +str -vc -ant +dist]
     symbol J\  [+cons -son -cont +vc -ant +dist]
     symbol j\  [+cons -son +cont -str +vc -ant +dist]
     symbol Z   [+cons -son +cont +str +vc -ant +dist]
     
     # Retroflex #
     
     symbol t`  [+cons -son -cont -vc -ant -dist]
     symbol s`  [+cons -son +cont +str -vc -ant -dist]
     symbol d`  [+cons -son -cont +vc -ant -dist]
     symbol z`  [+cons -son +cont +str +vc -ant -dist]
     
     # Velar #
     
     symbol k   [+cons -son -cont -vc +bk -lo +hi]
     symbol x   [+cons -son +cont -str -vc +bk -lo +hi]
     symbol g   [+cons -son -cont +vc +bk -lo +hi]
     symbol G   [+cons -son +cont -str +vc +bk -lo +hi]
     
     # Uvular #
     
     symbol q   [+cons -son -cont -vc +bk -lo -hi]
     symbol X   [+cons -son +cont -str -vc +bk -lo -hi]
     symbol G\  [+cons -son -cont +vc +bk -lo -hi]
     symbol R   [+cons -son +cont -str +vc +bk -lo -hi]
     
     # Pharyngeal #
     
     symbol X\  [+cons -son +cont -str -vc +bk +lo -hi]
     symbol ?\  [+cons -son +cont -str +vc +bk +lo -hi]
     
     # Glottal #
     
     symbol ?   [+cons -son -cont -vc]
     symbol h   [+cons -son +cont -str -vc]
     symbol h\  [+cons -son +cont -str +vc]
     
     ## Sonorants ##
     
     # Labial #
     
     symbol m   [+cons +son -cont +nas -lat -ro]
     symbol B\  [+cons +son +cont -nas -lat -ro]
     
     # Alveolar #
     
     symbol n   [+cons +son -cont +nas -lat +ant -dist]
     symbol l   [+cons +son -cont -nas +lat +ant -dist]
     symbol 4   [+cons +son -cont -nas -lat +ant -dist]
     symbol r   [+cons +son +cont -nas -lat +ant -dist]
     symbol r\  [-cons +son +cont -nas -lat +ant -dist]
     
     # Retroflex #
     
     symbol n`  [+cons +son -cont +nas -lat -ant -dist]
     symbol l`  [+cons +son -cont -nas +lat -ant -dist]
     
     # Postalveolar #
     
     symbol J   [+cons +son -cont +nas -lat -ant +dist]
     symbol L   [+cons +son -cont -nas +lat -ant +dist]
     
     # Velar #
     
     symbol N   [+cons +son -cont +nas -lat +bk -lo +hi]
     symbol L\  [+cons +son -cont -nas +lat +bk -lo +hi]
     
     # Uvular #
     
     symbol N\  [+cons +son -cont +nas -lat +bk -lo -hi]
     symbol R\  [+cons +son +cont -nas -lat +bk -lo -hi]
     
     ### Vocoids ###
     
     ## Vowels ##
     
     # High tense #
     
     symbol i   [-cons +son +syll +fr -bk +hi -lo +str]
     symbol y   [-cons +son +syll +fr -bk +hi -lo +ro +str]
     symbol 1   [-cons +son +syll -fr -bk +hi -lo +str]
     symbol }   [-cons +son +syll -fr -bk +hi -lo +ro +str]
     symbol M   [-cons +son +syll -fr +bk +hi -lo +str]
     symbol u   [-cons +son +syll -fr +bk +hi -lo +ro +str]
     
     # High lax #
     
     symbol I   [-cons +son +syll +fr -bk +hi -lo -str]
     symbol Y   [-cons +son +syll +fr -bk +hi -lo +ro -str]
     symbol I\  [-cons +son +syll -fr -bk +hi -lo -str]
     symbol U\  [-cons +son +syll -fr -bk +hi -lo +ro -str]
     symbol U   [-cons +son +syll -fr +bk +hi -lo +ro -str]
     
     # High mid #
     
     symbol e   [-cons +son +syll +fr -bk -hi -lo +str]
     symbol 2   [-cons +son +syll +fr -bk -hi -lo +ro +str]
     symbol @\  [-cons +son +syll -fr -bk -hi -lo +str]
     symbol 8   [-cons +son +syll -fr -bk -hi -lo +ro +str]
     symbol 7   [-cons +son +syll -fr +bk -hi -lo +str]
     symbol o   [-cons +son +syll -fr +bk -hi -lo +ro +str]
     
     # Schwa #
     
     symbol @   [-cons +son +syll -fr -bk -hi -lo -str]
     
     # Open mid #
     
     symbol E   [-cons +son +syll +fr -bk -hi -lo -str]
     symbol 9   [-cons +son +syll +fr -bk -hi -lo +ro -str]
     # Omitted: /3/, which is identical, feature-wise to /@/
     symbol 3\  [-cons +son +syll -fr -bk -hi -lo +ro -str]
     symbol V   [-cons +son +syll -fr +bk -hi -lo -str]
     symbol O   [-cons +son +syll -fr +bk -hi -lo +ro -str]
     
     # Open lax #
     
     symbol {   [-cons +son +syll -fr -bk -hi +lo -str]
     symbol 6   [-cons +son +syll -fr +bk -hi +lo -str]
     
     # Open #
     
     symbol a   [-cons +son +syll -fr -bk -hi +lo +str]
     symbol &amp;   [-cons +son +syll -fr -bk -hi +lo -ro +str]
     symbol A   [-cons +son +syll -fr +bk -hi +lo +str]
     symbol Q   [-cons +son +syll -fr +bk -hi +lo -ro +str]
     
     ## Semivowels ##
     
     symbol j   [-cons +son -syll +fr -bk +hi -lo +str]
     symbol H   [-cons +son -syll +fr -bk +hi -lo +ro +str]
     symbol w   [-cons +son -syll -fr +bk +hi -lo +ro +str]
</pre></pre>
   <p><a name="std.symbols.ipa"></a>
<a name="std_002esymbols_002eipa"></a>

<h4 class="subsection">3.5.4 std.symbols.ipa</h4>

<p>The IPA symbol set contains the same notional symbols as <code>std.symbols</code>,
but it uses IPA Unicode characters instead of ASCII X-SAMPA. To use the IPA
symbol set, write <code>import std.features</code> and <code>import std.symbols.ipa</code>
at the top of your file.

<pre class="example"><pre class="verbatim">     ### CONSONANTS ###
     
     ## Obstruents ##
     
     # Labial #
     
     symbol p   [+cons -son -cont -vc -ro]
     symbol ɸ   [+cons -son +cont -str -vc -ro]
     symbol f   [+cons -son +cont +str -vc -ro]
     symbol b   [+cons -son -cont +vc -ro]
     symbol β   [+cons -son +cont -str +vc -ro]
     symbol v   [+cons -son +cont +str +vc -ro]
     
     # Dental #
     
     symbol θ   [+cons -son +cont -str -vc +ant +dist]
     symbol ð   [+cons -son +cont -str +vc +ant +dist]
     
     # Alveolar #
     
     symbol t   [+cons -son -cont -vc +ant -dist]
     symbol s   [+cons -son +cont +str -vc +ant -dist]
     symbol d   [+cons -son -cont +vc +ant -dist]
     symbol z   [+cons -son +cont +str +vc +ant -dist]
     
     # Palatal #
     
     symbol c   [+cons -son -cont -vc -ant +dist]
     symbol ç   [+cons -son +cont -str -vc -ant +dist]
     symbol ʃ   [+cons -son +cont +str -vc -ant +dist]
     symbol ɟ   [+cons -son -cont +vc -ant +dist]
     symbol ʝ   [+cons -son +cont -str +vc -ant +dist]
     symbol ʒ   [+cons -son +cont +str +vc -ant +dist]
     
     # Retroflex #
     
     symbol ʈ   [+cons -son -cont -vc -ant -dist]
     symbol ʂ   [+cons -son +cont +str -vc -ant -dist]
     symbol ɖ   [+cons -son -cont +vc -ant -dist]
     symbol ʐ   [+cons -son +cont +str +vc -ant -dist]
     
     # Velar #
     
     symbol k   [+cons -son -cont -vc +bk -lo +hi]
     symbol x   [+cons -son +cont -str -vc +bk -lo +hi]
     symbol g   [+cons -son -cont +vc +bk -lo +hi]
     symbol ɣ   [+cons -son +cont -str +vc +bk -lo +hi]
     
     # Uvular #
     
     symbol q   [+cons -son -cont -vc +bk -lo -hi]
     symbol χ   [+cons -son +cont -str -vc +bk -lo -hi]
     symbol ɢ   [+cons -son -cont +vc +bk -lo -hi]
     symbol ʁ   [+cons -son +cont -str +vc +bk -lo -hi]
     
     # Pharyngeal #
     
     symbol ħ   [+cons -son +cont -str -vc +bk +lo -hi]
     symbol ʕ   [+cons -son +cont -str +vc +bk +lo -hi]
     
     # Glottal #
     
     symbol ʔ   [+cons -son -cont -vc]
     symbol h   [+cons -son +cont -str -vc]
     symbol ɦ   [+cons -son +cont -str +vc]
     
     ## Sonorants ##
     
     # Labial #
     
     symbol m   [+cons +son -cont +nas -lat -ro]
     symbol ʙ   [+cons +son +cont -nas -lat -ro]
     
     # Alveolar #
     
     symbol n   [+cons +son -cont +nas -lat +ant -dist]
     symbol l   [+cons +son -cont -nas +lat +ant -dist]
     symbol ɾ   [+cons +son -cont -nas -lat +ant -dist]
     symbol r   [+cons +son +cont -nas -lat +ant -dist]
     symbol ɹ   [-cons +son +cont -nas -lat +ant -dist]
     
     # Retroflex #
     
     symbol ɳ   [+cons +son -cont +nas -lat -ant -dist]
     symbol ɭ   [+cons +son -cont -nas +lat -ant -dist]
     
     # Postalveolar #
     
     symbol ɲ   [+cons +son -cont +nas -lat -ant +dist]
     symbol ʎ   [+cons +son -cont -nas +lat -ant +dist]
     
     # Velar #
     
     symbol ŋ   [+cons +son -cont +nas -lat +bk -lo +hi]
     symbol ʟ   [+cons +son -cont -nas +lat +bk -lo +hi]
     
     # Uvular #
     
     symbol ɴ   [+cons +son -cont +nas -lat +bk -lo -hi]
     symbol ʀ   [+cons +son +cont -nas -lat +bk -lo -hi]
     
     ### Vocoids ###
     
     ## Vowels ##
     
     # High tense #
     
     symbol i   [-cons +son +syll +fr -bk +hi -lo +str]
     symbol y   [-cons +son +syll +fr -bk +hi -lo +ro +str]
     symbol ɨ   [-cons +son +syll -fr -bk +hi -lo +str]
     symbol ʉ   [-cons +son +syll -fr -bk +hi -lo +ro +str]
     symbol ɯ   [-cons +son +syll -fr +bk +hi -lo +str]
     symbol u   [-cons +son +syll -fr +bk +hi -lo +ro +str]
     
     # High lax #
     
     symbol ɪ   [-cons +son +syll +fr -bk +hi -lo -str]
     symbol ʏ   [-cons +son +syll +fr -bk +hi -lo +ro -str]
     symbol ᵻ   [-cons +son +syll -fr -bk +hi -lo -str]
     symbol ᵿ   [-cons +son +syll -fr -bk +hi -lo +ro -str]
     symbol ʊ   [-cons +son +syll -fr +bk +hi -lo +ro -str]
     
     # High mid #
     
     symbol e   [-cons +son +syll +fr -bk -hi -lo +str]
     symbol ø   [-cons +son +syll +fr -bk -hi -lo +ro +str]
     symbol ɘ   [-cons +son +syll -fr -bk -hi -lo +str]
     symbol ɵ   [-cons +son +syll -fr -bk -hi -lo +ro +str]
     symbol ɤ   [-cons +son +syll -fr +bk -hi -lo +str]
     symbol o   [-cons +son +syll -fr +bk -hi -lo +ro +str]
     
     # Schwa #
     
     symbol ə   [-cons +son +syll -fr -bk -hi -lo -str]
     
     # Open mid #
     
     symbol ɛ   [-cons +son +syll +fr -bk -hi -lo -str]
     symbol œ   [-cons +son +syll +fr -bk -hi -lo +ro -str]
     # Omitted: /ɜ/, which is identical, feature-wise to /ə/
     symbol ɞ   [-cons +son +syll -fr -bk -hi -lo +ro -str]
     symbol ʌ   [-cons +son +syll -fr +bk -hi -lo -str]
     symbol ɔ   [-cons +son +syll -fr +bk -hi -lo +ro -str]
     
     # Open lax #
     
     symbol æ   [-cons +son +syll -fr -bk -hi +lo -str]
     symbol ɐ   [-cons +son +syll -fr +bk -hi +lo -str]
     
     # Open #
     
     symbol a   [-cons +son +syll -fr -bk -hi +lo +str]
     symbol ɶ   [-cons +son +syll -fr -bk -hi +lo -ro +str]
     symbol ɑ   [-cons +son +syll -fr +bk -hi +lo +str]
     symbol ɒ   [-cons +son +syll -fr +bk -hi +lo -ro +str]
     
     ## Semivowels ##
     
     symbol j   [-cons +son -syll +fr -bk +hi -lo +str]
     symbol ɥ   [-cons +son -syll +fr -bk +hi -lo +ro +str]
     symbol w   [-cons +son -syll -fr +bk +hi -lo +ro +str]
</pre></pre>
   <p><a name="Comments"></a>

<h3 class="section">3.6 Comments</h3>

<p>In Phonix the comment character is <code>#</code>. Everything from <code>#</code> to the
end of a line is a comment and is silently ignored by Phonix (unless the
<code>#</code> character is embedded in a string). For example:

<pre class="example">     # This is a comment
     feature ex # this comment explains what 'ex' means
</pre>
   <p><a name="Strings"></a>

<h3 class="section">3.7 Strings</h3>

<p>Any time that Phonix expects you to provide a string, as for feature names,
symbols, or a rule names, you can type almost anything you want.  The only
exception is if the contents of the string somehow confuse the Phonix compiler. 
Don't do that. Everything else is fine.

   <p>The long, boring, technical version follows.

   <p>Phonix recognizes two types of strings: <dfn>bare</dfn> strings and <dfn>quoted</dfn>
strings. Most of the time you can use bare strings, which keeps your Phonix
file nice and uncluttered. The rules for bare strings are extremely forgiving,
to minimize the situation where you have to use a quoted string:

     <ul>
<li>A bare string cannot contain whitespace. More specifically, whitespace is
always interpreted as a token delimiter outside of a quoted string, which
implicitly means it cannot be part of a string.

     <li>A bare string cannot contain any of the characters <code>[]()$=</code> <em>at
all</em>.

     <li>A bare string cannot begin with any of the characters <code>+-*/#_"'</code>. 
However, these characters can appear in the middle of strings.

   </ul>

   <p>This should be enough for almost all cases, but in case it's not, you can also
create a quoted string by surrounding a string with single quotes (<code>'</code>) or
double quotes (<code>"</code>). If you are using a quoted string in a rule or a
symbol declaration, the opening quote must be preceded by a space. Anything at
all can appear inside a quoted string, except for another quote, of course. 
There is no mechanism for escaping quotes, so if you need to include a single
quote then surround your quote with double quotes, and vice versa.

<p><a name="Examples"></a>

<h2 class="chapter">4 Examples</h2>

<p>The following examples illustrate common use cases for Phonix.

<p><a name="Romanian"></a>

<h3 class="section">4.1 Romanian</h3>

<p>The following example files define a phonology for contemporary Romanian, and
illustrates how most of the surface alternations in Romanian can be derived. 
Note that the example is somewhat incomplete: the input represents an internal
reconstruction of Proto-Romanian, not Proto-Romance or Vulgar Latin, and there
may be a few alternations that slipped by me. However, the majority of the
active phonological processes in Romanian should be represented.

<h4 class="subsection">4.1.1 <samp><span class="file">romanian.phonix</span></samp></h4>

<pre class="example"><pre class="verbatim">     import std.features
     
     # 
     # We add a feature for stress, which is important for many rules
     #
     feature stress
     
     #
     # We create our own symbol set, defining only Romanian phonemes
     #
     
     # Unstressed vowels
     symbol a  [+syll -cons +son -hi +lo -fr -bk -stress]
     symbol e  [+syll -cons +son -hi -lo +fr -bk -stress]
     symbol o  [+syll -cons +son -hi -lo -fr +bk +ro -stress]
     symbol @  [+syll -cons +son -hi -lo -fr -bk -stress]
     symbol i  [+syll -cons +son +hi -lo +fr -bk -stress]
     symbol u  [+syll -cons +son +hi -lo -fr +bk +ro -stress]
     symbol 1  [+syll -cons +son +hi -lo -fr -bk -stress]
     
     # Stress diacritic
     symbol "'"  (diacritic) [+stress]
     
     # Non-syllabic vocoids
     symbol j  [-syll -cons +son +hi -lo +fr -bk -stress]
     symbol w  [-syll -cons +son +hi -lo -fr +bk +ro -stress]
     
     # Non-syllabic diacritic
     symbol `  (diacritic) [-syll]
     
     # Labials
     symbol p  [+cons +ro -son]
     symbol b  [+cons +ro -son +vc]
     symbol f  [+cons +ro -son +cont]
     symbol v  [+cons +ro -son +cont +vc]
     symbol m  [+cons +ro +son +nas]
     
     # Dentals
     symbol t  [+cons +ant -son]
     symbol ts  [+cons +ant -son +dr]
     symbol d  [+cons +ant -son +vc]
     symbol dz  [+cons +ant -son +dr +vc]
     symbol s  [+cons +cont -son +ant]
     symbol z  [+cons +cont -son +ant +vc]
     symbol n  [+cons +ant +son +nas]
     symbol l  [+cons +ant +son +lat]
     symbol r  [+cons +ant +son +cont]
     
     # Palatals
     symbol tS  [+cons -son -ant +dist +dr]
     symbol dZ  [+cons -son -ant +dist +vc +dr]
     symbol S  [+cons -son -ant +cont +dist]
     symbol Z  [+cons -son -ant +cont +dist +vc]
     
     # Velars
     symbol k  [+cons -son +hi]
     symbol g  [+cons -son +hi +vc]
     symbol h  [+cons -son +hi +cont]
     
     #
     # Here we begin with the rules
     #
     
     # Reduce i/u to semivowels where appropriate
     rule make-semivowels
     [+hi +syll] => [-syll] / [+syll] _
     
     # Stress all penult syllables. This rule illustrates two interesting
     # techniques. First, it specifies a filter of [+syll], which means that the
     # rule only "sees" [+syll] segments. Second, it uses an empty set of braces []
     # to match "any segment".
     rule stress-penult (filter=[+syll])
     [] => [+stress] / _ [] $
     
     # When the antepenult syllable is lexically stressed, remove stress on the
     # penult syllable. 
     rule stress-antepenult (filter=[+syll])
     [+stress] => [-stress] / [+stress] _
     
     # Break word-initial /e/
     rule initial-iotacization
     * => j / $ _ [+fr -hi -lo]
     
     # Palatalize velars before front vowels
     rule palatalize-velars
     [+cons +hi] => [-ant +dist +dr *hi] / _ [+fr]
     
     # Palatalize dental fricatives before high front vowels
     rule palatalize-dentals
     [+cons +ant +cont -son] => [-ant +dist] / _ [+hi +fr]
     
     # Assimilate palatalization
     rule assimilate-palatals
     [+cons -son *ro] => [-ant +dist] / _ [-ant +dist]
     
     # Affricate dental stops before /i/
     rule affricate-dentals
     [+cons +ant -son] => [+dr] / _ i
     
     # Simplify /dz/
     rule simplify-dz
     dz => z
     
     # Simplify /StS/ everywhere
     rule simplify-StS
     StS => St
     
     # Change velar+/l/ to a palatalized velar
     rule l-palatalize
     l => j / [+cons +hi] _
     
     # Raise stressed central vowels before /n/
     rule prenasal-raising
     [-hi -lo +stress] => [+hi] / _ n
     
     # Centralize front non-high vowels after labials
     rule postlabial-centralize
     [-hi +fr] => [-fr] / [+ro] _
     
     # Front central vowels when the next vowel is a front vowel
     rule front-assimilation (filter=[-cons])
     [-fr -bk -lo] => [+fr] / _ [+fr]
     
     # Raise unstressed /o/
     rule o-raising (filter=[+syll])
     o => u / _ [+stress]
     
     # Drop word-final /u/
     rule drop-final-u
     u => * / _ $
     
     # Desyllabify word-final /i/
     rule desyllabify-final-i
     i => j / _ $
     
     # Centralize unstressed /a/, except when /a/ is the first segment
     rule centralize-a
     a => @ / [] _
     
     # Centralize /a/ in the 1pl verbal ending
     rule centralize-1pl-a
     a' => @' / _m $
     
     # Break stressed mid vowels into semivowel + a when the next syllable contains
     # a non-high vowel
     rule breaking (filter=[+syll])
     [-hi -lo +stress] * => [-syll -stress] a' / _ [-hi *ro]
     
     # Assimilate /ea/ followed by /e/
     rule assimilate-ea (filter=[-cons])
     e`a' => e' * / _ e
     
     # Assimilate /oa/ followed by /w/
     rule assimilate-oa
     o`a' => o' * / _ w
     
     # Assimilate semivowels after a palatal
     rule assimilate-postpalatal-semivowel
     [-syll +fr] => * / [+dr +dist] _
     
     # Assimilate consecutive semivowels of the same frontness
     rule assimilate-consecutive-semivowel
     [-syll $fr] => * / [-syll $fr] _
     
     # Assimilate coronal sonorants before /j/
     rule assimilate-sonorants
     [+cons +ant +son *cont] => * / _ j
     
     # Drop non-syllabic central vowels
     rule drop-central-vocoids
     [-fr -bk -syll] => *
</pre></pre>
<h4 class="subsection">4.1.2 Input and output</h4>

<p>You can generate the output file with the following command line:

<pre class="example">     phonix romanian.phonix -i romanian.input -o romanian.output
</pre>
   <p>The following table shows the input and the generated output together with the
output form in Romanian orthography.

   <p><table summary=""><tr align="left"><th valign="top" width="25%">Input </th><th valign="top" width="25%">Output </th><th valign="top" width="50%">Orthography
<br></th></tr><tr align="left"><td valign="top" width="25%"><code>vedu</code> </td><td valign="top" width="25%"><code>v@'d</code> </td><td valign="top" width="50%">văd
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>vedi</code> </td><td valign="top" width="25%"><code>ve'zj</code> </td><td valign="top" width="50%">vezi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>vede</code> </td><td valign="top" width="25%"><code>ve'de</code> </td><td valign="top" width="50%">vede
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>vedemu</code> </td><td valign="top" width="25%"><code>vede'm</code> </td><td valign="top" width="50%">vedem
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>vedeti</code> </td><td valign="top" width="25%"><code>vede'tsj</code> </td><td valign="top" width="50%">vedeţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>vedu</code> </td><td valign="top" width="25%"><code>v@'d</code> </td><td valign="top" width="50%">văd
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>veda</code> </td><td valign="top" width="25%"><code>va'd@</code> </td><td valign="top" width="50%">vadă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>vezutu</code> </td><td valign="top" width="25%"><code>v@zu't</code> </td><td valign="top" width="50%">văzut
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>venu</code> </td><td valign="top" width="25%"><code>vi'n</code> </td><td valign="top" width="50%">vin
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>veni</code> </td><td valign="top" width="25%"><code>vi'j</code> </td><td valign="top" width="50%">vii
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>vene</code> </td><td valign="top" width="25%"><code>vi'ne</code> </td><td valign="top" width="50%">vine
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>venimu</code> </td><td valign="top" width="25%"><code>veni'm</code> </td><td valign="top" width="50%">venim
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>veniti</code> </td><td valign="top" width="25%"><code>veni'tsj</code> </td><td valign="top" width="50%">veniţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>venu</code> </td><td valign="top" width="25%"><code>vi'n</code> </td><td valign="top" width="50%">vin
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>vena</code> </td><td valign="top" width="25%"><code>vi'n@</code> </td><td valign="top" width="50%">vină
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>venitu</code> </td><td valign="top" width="25%"><code>veni't</code> </td><td valign="top" width="50%">venit
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>esu</code> </td><td valign="top" width="25%"><code>je's</code> </td><td valign="top" width="50%">ies
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>esi</code> </td><td valign="top" width="25%"><code>je'Sj</code> </td><td valign="top" width="50%">ieşi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>ese</code> </td><td valign="top" width="25%"><code>je'se</code> </td><td valign="top" width="50%">iese
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>esimu</code> </td><td valign="top" width="25%"><code>jeSi'm</code> </td><td valign="top" width="50%">ieşim
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>esiti</code> </td><td valign="top" width="25%"><code>jeSi'tsj</code> </td><td valign="top" width="50%">ieşiţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>esu</code> </td><td valign="top" width="25%"><code>je's</code> </td><td valign="top" width="50%">ies
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>esa</code> </td><td valign="top" width="25%"><code>ja's@</code> </td><td valign="top" width="50%">iasă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>esitu</code> </td><td valign="top" width="25%"><code>jeSi't</code> </td><td valign="top" width="50%">ieşit
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>potu</code> </td><td valign="top" width="25%"><code>po't</code> </td><td valign="top" width="50%">pot
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>poti</code> </td><td valign="top" width="25%"><code>po'tsj</code> </td><td valign="top" width="50%">poţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>pote</code> </td><td valign="top" width="25%"><code>po`a'te</code> </td><td valign="top" width="50%">poate
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>potemu</code> </td><td valign="top" width="25%"><code>pute'm</code> </td><td valign="top" width="50%">putem
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>poteti</code> </td><td valign="top" width="25%"><code>pute'tsj</code> </td><td valign="top" width="50%">puteţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>potu</code> </td><td valign="top" width="25%"><code>po't</code> </td><td valign="top" width="50%">pot
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>pota</code> </td><td valign="top" width="25%"><code>po`a't@</code> </td><td valign="top" width="50%">poată
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>potutu</code> </td><td valign="top" width="25%"><code>putu't</code> </td><td valign="top" width="50%">putut
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>keru</code> </td><td valign="top" width="25%"><code>tSe'r</code> </td><td valign="top" width="50%">cer
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>keri</code> </td><td valign="top" width="25%"><code>tSe'rj</code> </td><td valign="top" width="50%">ceri
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>kere</code> </td><td valign="top" width="25%"><code>tSe're</code> </td><td valign="top" width="50%">cere
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>ke'remu</code> </td><td valign="top" width="25%"><code>tSe'rem</code> </td><td valign="top" width="50%">cerem
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>ke'reti</code> </td><td valign="top" width="25%"><code>tSe'retsj</code> </td><td valign="top" width="50%">cereţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>keru</code> </td><td valign="top" width="25%"><code>tSe'r</code> </td><td valign="top" width="50%">cer
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>kera</code> </td><td valign="top" width="25%"><code>tSa'r@</code> </td><td valign="top" width="50%">ceară
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>kerutu</code> </td><td valign="top" width="25%"><code>tSeru't</code> </td><td valign="top" width="50%">cerut
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>portu</code> </td><td valign="top" width="25%"><code>po'rt</code> </td><td valign="top" width="50%">port
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>porti</code> </td><td valign="top" width="25%"><code>po'rtsj</code> </td><td valign="top" width="50%">porţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>porta</code> </td><td valign="top" width="25%"><code>po`a'rt@</code> </td><td valign="top" width="50%">poartă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>portamu</code> </td><td valign="top" width="25%"><code>purt@'m</code> </td><td valign="top" width="50%">purtăm
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>portati</code> </td><td valign="top" width="25%"><code>purta'tsj</code> </td><td valign="top" width="50%">purtaţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>porta</code> </td><td valign="top" width="25%"><code>po`a'rt@</code> </td><td valign="top" width="50%">poartă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>porte</code> </td><td valign="top" width="25%"><code>po`a'rte</code> </td><td valign="top" width="50%">poarte
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>portatu</code> </td><td valign="top" width="25%"><code>purta't</code> </td><td valign="top" width="50%">purtat
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>freku</code> </td><td valign="top" width="25%"><code>fre'k</code> </td><td valign="top" width="50%">frec
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>freki</code> </td><td valign="top" width="25%"><code>fre'tS</code> </td><td valign="top" width="50%">freci
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>freka</code> </td><td valign="top" width="25%"><code>fre`a'k@</code> </td><td valign="top" width="50%">freacă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>frekamu</code> </td><td valign="top" width="25%"><code>frek@'m</code> </td><td valign="top" width="50%">frecăm
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>frekati</code> </td><td valign="top" width="25%"><code>freka'tsj</code> </td><td valign="top" width="50%">frecaţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>freka</code> </td><td valign="top" width="25%"><code>fre`a'k@</code> </td><td valign="top" width="50%">freacă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>freke</code> </td><td valign="top" width="25%"><code>fre'tSe</code> </td><td valign="top" width="50%">frece
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>klemu</code> </td><td valign="top" width="25%"><code>kje'm</code> </td><td valign="top" width="50%">chem
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>klemi</code> </td><td valign="top" width="25%"><code>kje'mj</code> </td><td valign="top" width="50%">chemi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>klema</code> </td><td valign="top" width="25%"><code>kja'm@</code> </td><td valign="top" width="50%">cheamă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>klemamu</code> </td><td valign="top" width="25%"><code>kjem@'m</code> </td><td valign="top" width="50%">chemăm
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>klemati</code> </td><td valign="top" width="25%"><code>kjema'tsj</code> </td><td valign="top" width="50%">chemaţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>klema</code> </td><td valign="top" width="25%"><code>kja'm@</code> </td><td valign="top" width="50%">cheamă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>kleme</code> </td><td valign="top" width="25%"><code>kja'm@</code> </td><td valign="top" width="50%">cheamă *Note that this is the regular outcome of the sound change, but this form (the 3rd person subjunctive) has been analogically restored to 'cheme' in the standard language. 
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>kalu</code> </td><td valign="top" width="25%"><code>ka'l</code> </td><td valign="top" width="50%">cal
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>kali</code> </td><td valign="top" width="25%"><code>ka'j</code> </td><td valign="top" width="50%">cai
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>udu</code> </td><td valign="top" width="25%"><code>u'd</code> </td><td valign="top" width="50%">ud
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>uda</code> </td><td valign="top" width="25%"><code>u'd@</code> </td><td valign="top" width="50%">udă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>ude</code> </td><td valign="top" width="25%"><code>u'de</code> </td><td valign="top" width="50%">ude
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>udi</code> </td><td valign="top" width="25%"><code>u'zj</code> </td><td valign="top" width="50%">uzi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>pro'spetu</code> </td><td valign="top" width="25%"><code>pro`a'sp@t</code> </td><td valign="top" width="50%">proaspăt
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>pro'speta</code> </td><td valign="top" width="25%"><code>pro`a'sp@t@</code> </td><td valign="top" width="50%">proaspătă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>pro'speti</code> </td><td valign="top" width="25%"><code>pro`a'spetsj</code> </td><td valign="top" width="50%">proaspeţi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>pro'spete</code> </td><td valign="top" width="25%"><code>pro`a'spete</code> </td><td valign="top" width="50%">proaspete
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>osu</code> </td><td valign="top" width="25%"><code>o's</code> </td><td valign="top" width="50%">os
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>ose</code> </td><td valign="top" width="25%"><code>o`a'se</code> </td><td valign="top" width="50%">oase
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>oie</code> </td><td valign="top" width="25%"><code>o`a'je</code> </td><td valign="top" width="50%">oaie
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>oi</code> </td><td valign="top" width="25%"><code>oj</code> </td><td valign="top" width="50%">oi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>ou</code> </td><td valign="top" width="25%"><code>ow</code> </td><td valign="top" width="50%">ou
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>oue</code> </td><td valign="top" width="25%"><code>o'w@</code> </td><td valign="top" width="50%">ouă
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>peske</code> </td><td valign="top" width="25%"><code>pe'Ste</code> </td><td valign="top" width="50%">peşte
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>peski</code> </td><td valign="top" width="25%"><code>pe'Stj</code> </td><td valign="top" width="50%">peşti
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>oklu</code> </td><td valign="top" width="25%"><code>o'kj</code> </td><td valign="top" width="50%">ochi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>okli</code> </td><td valign="top" width="25%"><code>o'kj</code> </td><td valign="top" width="50%">ochi
<br></td></tr><tr align="left"><td valign="top" width="25%"><code>klaru</code> </td><td valign="top" width="25%"><code>kja'r</code> </td><td valign="top" width="50%">chiar
   <br></td></tr></table>

<p><a name="License"></a>

<h2 class="appendix">Appendix A License</h2>

<p>This is the license for the Phonix Phonological Transformation Language, the
program `phonix.exe' in source and binary forms, and for the Phonix manual.

   <p>Copyright (C) 2009 Jesse Bangs
All rights reserved.

   <p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

   <p>* Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

   <p>* Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

   <p>* Neither the name of Jesse Bangs nor the names of its contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.

   <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
